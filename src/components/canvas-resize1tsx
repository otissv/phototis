// Function to recalculate layer positions when canvas dimensions change
const recalculateLayerPositions = React.useCallback(
  (layers: [string, LayerDimensions][]) => {
    const currentCanvasWidth = canvasDimensions.width
    const currentCanvasHeight = canvasDimensions.height
    const canvasPosition = canonicalStateRef.current.document.canvasPosition

    // state.canonical.layers.byId[id].filters.dimensions

    // Helper function to calculate position based on canvas anchor point
    const calculatePositionFromAnchor = (
      layerWidth: number,
      layerHeight: number,
      canvasWidth: number,
      canvasHeight: number,
      anchor: CanvasPosition
    ): { x: number; y: number } => {
      let x: number
      let y: number

      switch (anchor) {
        case "topLeft":
          x = 0
          y = 0
          break
        case "topCenter":
          x = (canvasWidth - layerWidth) / 2
          y = 0
          break
        case "topRight":
          x = canvasWidth - layerWidth
          y = 0
          break
        case "centerLeft":
          x = 0
          y = (canvasHeight - layerHeight) / 2
          break
        case "centerCenter":
          x = (canvasWidth - layerWidth) / 2
          y = (canvasHeight - layerHeight) / 2
          break
        case "centerRight":
          x = canvasWidth - layerWidth
          y = (canvasHeight - layerHeight) / 2
          break
        case "bottomLeft":
          x = 0
          y = canvasHeight - layerHeight
          break
        case "bottomCenter":
          x = (canvasWidth - layerWidth) / 2
          y = canvasHeight - layerHeight
          break
        case "bottomRight":
          x = canvasWidth - layerWidth
          y = canvasHeight - layerHeight
          break
        default:
          // Fallback to center-center
          x = (canvasWidth - layerWidth) / 2
          y = (canvasHeight - layerHeight) / 2
      }

      // For layers larger than canvas, we need to handle them specially
      // to maintain the intended positioning while keeping them visible
      if (layerWidth > canvasWidth) {
        // If layer is wider than canvas, adjust x to keep it visible
        // but maintain the intended horizontal alignment
        if (anchor.endsWith("Left")) {
          x = 0 // Keep left-aligned
        } else if (anchor.endsWith("Right")) {
          x = canvasWidth - layerWidth // Keep right-aligned
        } else {
          x = (canvasWidth - layerWidth) / 2 // Center horizontally
        }
      }

      if (layerHeight > canvasHeight) {
        // If layer is taller than canvas, adjust y to keep it visible
        // but maintain the intended vertical alignment
        if (anchor.startsWith("top")) {
          y = 0 // Keep top-aligned
        } else if (anchor.startsWith("bottom")) {
          y = canvasHeight - layerHeight // Keep bottom-aligned
        } else {
          y = (canvasHeight - layerHeight) / 2 // Center vertically
        }
      }

      // Only clamp coordinates if the layer would actually go outside bounds
      // and we're not dealing with a layer larger than the canvas
      if (layerWidth <= canvasWidth) {
        x = Math.max(0, Math.min(x, canvasWidth - layerWidth))
      }
      if (layerHeight <= canvasHeight) {
        y = Math.max(0, Math.min(y, canvasHeight - layerHeight))
      }

      return { x: Math.round(x), y: Math.round(y) }
    }

    // Update positions for all existing layers
    for (const [layerId, dimensions] of layers) {
      const imageData = imageDataCacheRef.current.get(layerId)

      if (!imageData) continue

      // Calculate new position based on canvas anchor point
      const { x: newX, y: newY } = calculatePositionFromAnchor(
        imageData.width,
        imageData.height,
        currentCanvasWidth,
        currentCanvasHeight,
        canvasPosition
      )

      // Update canonical state to persist the new positions
      // Get the current layer to preserve existing filter values
      const currentLayer = canonicalStateRef.current.layers.byId[layerId]

      const currentFilters = (currentLayer as any)?.filters || {}
      // const currentDimensions = currentFilters.dimensions || {}

      // Update local ref for immediate rendering
      layerDimensionsRef.current.set(layerId, {
        ...dimensions,
        x: newX,
        y: newY,
      })

      // Only update x,y coordinates, preserve existing width/height and other filter values
      updateLayer(layerId, {
        filters: {
          ...currentFilters,
          dimensions: {
            ...dimensions,
            x: newX,
            y: newY,
            width: dimensions.width,
            height: dimensions.height,
          },
        },
      } as any)
    }

    // Trigger a redraw to show updated positions
    // Use a callback approach to avoid drawRef dependency issues
    setTimeout(() => {
      // The draw function will be called when the component re-renders
      // due to the state updates from updateLayer calls
    }, 0)
  },
  [
    canvasDimensions.width,
    canvasDimensions.height,
    JSON.stringify(state.canonical.layers),
    updateLayer,
  ]
)

// Actually resize the canvas element when dimensions change
React.useEffect(() => {
  const canvas = canvasRef?.current
  if (!canvas) return

  // Update the actual canvas element dimensions
  canvas.width = canvasDimensions.width
  canvas.height = canvasDimensions.height

  // Clear WebGL caches to force reinitialization with new dimensions
  const gl = glRef.current
  if (gl) {
    // Clear texture cache
    for (const [key, tex] of Array.from(textureCacheRef.current.entries())) {
      gl.deleteTexture(tex)
    }
    textureCacheRef.current.clear()

    // Don't clear imageDataCacheRef - this contains the actual image data
    // that layers need for rendering. The canvas resize doesn't change image content.

    const stateLayerDimensions = Array.from(layerDimensionsRef.current)

    console.log(stateLayerDimensions)
    layerDimensionsRef.current.clear()
    recalculateLayerPositions(stateLayerDimensions)

    // Reset WebGL viewport to new dimensions
    gl.viewport(0, 0, canvasDimensions.width, canvasDimensions.height)
  }
}, [
  canvasDimensions.width,
  canvasDimensions.height,
  recalculateLayerPositions,
  canvasRef,
])
